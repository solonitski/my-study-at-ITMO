# Лабораторная работа №3
## STL-совместимый контейнер

### Инструментарий и требования к работе
Работа выполняется на C++. На сервере сборка под C++20.

### Задание
В программе должен быть реализован шаблонный класс `BucketStorage`, представляющий собой STL-совместимый контейнер. В качестве шаблонного параметра выступает `T` – тип хранимых элементов. Использовать STL или другие стандартные классы C++ с нетривиальными деструкторами (= отличными от деструктора, который вы получаете по умолчанию с классом, который ничего не делает) запрещено.

### Требования к контейнеру
Контейнер должен удовлетворять требованиям типа Container. Реализация без аллокаторов (`std::allocator`).

### Требования к контейнеру:
- DefaultConstructible
- CopyConstructible
- CopyAssignable
- MoveConstructible
- MoveAssignable
- Destructible

Все конструкторы/операторы из “правила пяти” должны быть реализованы с использованием идиомы copy and swap.

### Обработка ошибок
Обработка ошибок (например, неуспешное выделение памяти) должна реализовываться через исключения C++.

### Описание контейнера
Контейнер создан для сценариев с частыми созданием и удалением объектов фиксированного размера. Все элементы в контейнере имеют стабильное расположение в памяти, что означает, что указатели/итераторы на хранимые объекты действительны всё время жизни этих объектов независимо от вставок/удалений в контейнер других объектов.

Общая идея: контейнер хранит набор блоков, каждый из которых может хранить некоторое число объектов, и идентификаторы (числовые значения) для каждого места под объект (элемент блока), указывающие, является ли эта позиция “активной” или “свободной”. Если место помечено как “свободное”, то оно пропускается при переходе по итераторам. Когда весь блок свободен, то он удаляется. Если происходит вставка, когда все блоки заполнены, то выделяется новый блок.

### Контейнер хранит следующую информацию:
- Блоки памяти.
- Идентификаторы “активности”.
- Прочие метаданные (размер, вместимость, ...).

В массиве идентификаторов значение 0 указывает на то, что элемент “активен”, а значение большее 0 – расстояние, помогающее найти соседний активный элемент.

### Операция | Сложность
- Вставка элемента | O(1)
- Удаление элемента | O(1)
- Переход итератора на следующий/предыдущий активный элемент | O(1)

### Конструкторы
- По умолчанию (DefaultConstructible).
- Все из “правила пяти” (CopyConstructible, MoveConstructible).
- Устанавливающий вместимость блока (принимает `size_type block_capacity`). Создаёт контейнер и задаёт вместимость блока равным `block_capacity`.

По умолчанию `block_capacity` равен 64.

### Функции/операторы

| Функция/оператор | Описание |
|------------------|----------|
| `iterator insert (const value_type &value)` | Вставляет в контейнер объект (copy-constructor) |
| `iterator insert (value_type&& value)` | Вставляет в контейнер объект (move-constructor) |
| `iterator erase(const_iterator it)` | Удаляет объект, на который указывает итератор. Возвращает итератор на следующий (активный) элемент (или `end()`, если таковых нет). |
| `bool empty()` | Возвращает `true`, если контейнер пустой. |
| `size_type size()` | Возвращает число элементов, хранящихся в контейнере. |
| `size_type capacity()` | Возвращает число элементов, которые могут быть сохранены в контейнере без его расширения. |
| `void shrink_to_fit()` | Изменяет ёмкость (capacity) контейнера до минимально необходимого для хранения всех текущих элементов. Обратите внимание: этот метод может нарушать свойство стабильности адреса в памяти хранящихся объектов. |
| `void clear()` | Разрушает все объекты в контейнере и устанавливает размер `size()` в 0. |
| `void swap(BucketStorage &other)` | Меняет местами содержимое текущего и переданного контейнеров. |
| `iterator begin()`, `const_iterator begin()`, `const_iterator cbegin()` | Возвращают итераторы на первый элемент контейнера. |
| `iterator end()`, `const_iterator end()`, `const_iterator cend()` | Возвращают итераторы за последний элемент контейнера. |
| `iterator get_to_distance(iterator it, const difference_type distance)` | Сдвигает итератор на переданное расстояние (в элементах). Возвращает новый итератор. |

### Описание итератора
Помимо класса контейнера необходимо реализовать класс итератор, представляющий собой реализацию двунаправленного итератора (требования: bidirectional). Больше/меньше указывают на то, находится ли итератор дальше / ближе к концу по сравнению с другим итератором в том же контейнере. Асимптотика всех операций O(1).

### Операторы итератора
- `++`
- `==`
- `<`
- `<=`
- `*` (унарный)
- `=`
- `--`
- `!=`
- `>`
- `>=`
- `->`

### Правила инвалидации итераторов
| Случай | Инвалидация |
|--------|-------------|
| Все операции, не модифицирующие содержимое (read-only) | Не происходит |
| `clear`, `operator=` | Всегда |
| `shrink_to_fit` | если `capacity() != size()` |
| `erase` | Только на удаляемый элемент |
