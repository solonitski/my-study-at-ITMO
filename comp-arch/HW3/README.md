# Домашнее задание 3

## Структура процессора

Часть модулей, необходимых для реализации процессора реализована в файлах, а именно:
1) Память команд и данных, модуль `memory.v`
2) Регистровый файл, модуль `register_file.v`
3) Модуль для одиночного 32-битного регистра PC в `d_flop.v`
4) Модуль `util.v`содержит вспомогательные модули, которые могут быть полезны
   при реализации процессора.

Чтение из памяти и регистрового файла асинхронное, запись происходит по фронту сигнала синхронизации.

Обратите внимание, что память команд изначально заполняется двоичными данными из файла и является read-only.

Память данных и регистры изначально заполнены нулями.

Вашей задачей является реализация управляющего устройства и соединение всех остальных модулей
в работающий процессор.

Сам процессор необходимо реализовывать в модуле `mips_cpu.v`. Для упрощения
процесса тестирования процессор взаимодействует с регистром PC, памятью команд и данных, а также регистровым
файлом через входные/выходные порты.
Пример использования этого процессора можно найти в файле `cpu_test.v`,
в этом файле также находится простейший тестовый сценарий, который выполняет заданное количество инструкций, а затем
выводит содержимое регистров и памяти данных

## Часть 1. Реализация базовых инструкций.

В базовой части этого домашнего задания вам необходимо реализовать процессор, который реализует инструкции
`lw`, `sw`, `add`, `sub`, `and`, `or`, `slt`, `beq`.

Команды кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| lw      | 100011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| sw      | 101011 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| beq     | 000100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

| Команда | opcode | rs    | rt    | rd    | shamt | funct  |
|---------|--------|-------|-------|-------|-------|--------|
| add     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100000 |
| sub     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100010 |
| and     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100100 |
| or      | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 100101 |
| slt     | 000000 | xxxxx | xxxxx | xxxxx | 00000 | 101010 |

Напонимание: биты нумеруются справа налево, т.е. самый правый бит является самым младшим битом команды:)

Данная часть оценивается в 8 баллов (по баллу за каждую инструкцию).

## Часть 2. Реализация дополнительных инструкций I-типа

В данной части необходимо дополнительно реализовать инструкции `addi`, `andi`, `bne`.

Они кодируются следующим образом:

| Команда | opcode | rs    | rt    | imm              |
|---------|--------|-------|-------|------------------|
| addi*   | 001000 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| andi*   | 001100 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |
| bne     | 000101 | xxxxx | xxxxx | xxxxxxxxxxxxxxxx |

Данная часть оценивается в 4 балла: `addi` стоит 2 балла, `andi` и `bne` по 1 баллу.

### Часть 3. Реализация инструкций J-типа.

В данной части необходимо дополнительно реализовать инструкции `j`, `jal`.

Они кодируются следующим образом:

| Команда | opcode | addr                       |
|---------|--------|----------------------------|
| j       | 000010 | xxxxxxxxxxxxxxxxxxxxxxxxxx |
| jal     | 000011 | xxxxxxxxxxxxxxxxxxxxxxxxxx |

`addr` определяет новый PC следующим образом: `pc_new <- {0000, addr, 00}`

Данная часть оценивается в 4 балла, по 2 балла за реализацию каждой инструкции.
